__author__ = 'jet <jet@allartburns.org>'

import math
import sys
import re
import os.path
import StringIO


class NGCParser:
    """Parse subset of G-code that we can implement on the Lasersaur.

    Challenge: the lasersaur backend converts input files (DXF, SVG)
    to an interpreted format, the frontend UI takes direction from
    the end user, then g-code is generated.

    For this parser, we blindly accept whatever g-code is sent as if
    has come from the frontend.  We'll send back a DBA file an

    G-code generated by the lasersaur, *'d items are one that
    can import to DBA format.
    * G0 X1 Y1 traverse the head to 1,1 (done)
    * G0 F100 sets the traverse speed to 100mm/min (done)
    * G1 X1 Y1 cut the head to 1,1 (done)
    * G1 F100 sets the cut speed to 100mm/min (done)
    G4 pierce (TBD)
    G10 set offsets
    G10 L20 P0 - set table offset (G54) to current location
    G10 L20 P1 - set custom offset (G55) to current location
    G10 L2 P0 X20 Y20 - set table offset (G54) to 20,20
    G10 L2 P1 X220 Y140 - set custom offset (G55) to 220,140
    G30 homing cycle
    G54 use table switch offset
    G55 use custom swich offset
    G90 absolute coordinates
    G91 relative cooridantes
    * M80 air assist enable
    * M81 air assist disable
    M82 aux1 enable
    M83 aux1 disable
    M84 aux2 enable
    M85 aux2 disable

    * S spindle speed == intensity (done)
    
    Fake G-code:
    ! immediately stop operation, pause mode
    ~ contine, exit pause mode
    ? get full status string


TODO:
- every time we see a intensity or speed change
  (note: air_assist is automatically on/off for lasersaur)
    - close current path
    - find/create a corresponding passes entry with a matching color
      (so we can share DBA files with lasersaur frontend)
    - start a new path
    """

    def __init__(self):

        self.debug = True
  
        self.colors = ['#FF0000',
                       '#FFFF00',
                       '#00FF00',
                       '#00FFFF',
                       '#0000FF',
                       '#CC33CC',
                       '#000000']

        self.re_findall_attribs = re.compile('(S|F|X|Y|Z)(-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)').findall
        self.previousMotionSeek = True

        self.currentPath = []
        self.currentRate = 0
        self.currentIntensity = 0.0
        self.traverseRate = 0
        
        self.g0target = []

        # array of paths by item
        self.pathsByRate = {0:[]}

        # list of pass characteristics, format is
        # { path index, feedrate, intensity }
        self.passes = []

        # stats for this job
        #  bounding box, len
        #  { [x1,y1,x2,y2], 100 }
        self.stats = []


        
    def parse(self, ngcstring):

        self.intensity = 0.0
        self.feedRate = 0.0
        self.g0target = [0.0, 0.0, 0.0]


        lines = ngcstring.split('\n')
        for line in lines:
            line = line.replace(' ', '')
            if line.startswith('G0'):
                self.parseG0(line)
            elif line.startswith('G1'):
                self.parseG1(line)
            elif line.startswith('S'):
                self.parseS(line)
            else:
                self.wontParse(line)

        job = {'head':{}, 'passes':[], 'items':[], 'defs':[]}

        job['head']['optimized'] = 0.0
        job['head']['allow_optimize'] = False

        for path in self.pathsByRate:
            builtPath = []
            for p in self.pathsByRate[path]:
                for p1 in p:
                    builtPath.append(p1)
            defStr = {"kind":"path","data":builtPath}
            job['defs'].append(defStr)

        i = 0
        for index in self.passes:
            job['passes'].append(index)
            job['items'].append({'color': self.colors[i], 'def': i})
            i += 1


        return job


    def parseG0(self, line):
        
        if len(self.currentPath) > 0:
            self.pathsByRate[self.currentRate].append(self.currentPath)
            self.currentPath = []
            
        # we parse all the G0 commands but only care about the last
        # one before a cut
        #print("#parse G0 " + line)
        attribs = self.re_findall_attribs(line[2:])
        for attr in attribs:
            if attr[0] == 'X':
                self.g0target[0] = float(attr[1])
            elif attr[0] == 'Y':
                self.g0target[1] = float(attr[1])
            elif attr[0] == 'Z':
                self.g0target[2] = float(attr[1])
            elif attr[0] == 'F':
                self.adjustTraverseRate(float(attr[1]))
        self.previousMotionSeek = True


    def parseG1(self, line):
        #print("#parse G1 " + line)
        target = [0.0, 0.0, 0.0]
        attribs = self.re_findall_attribs(line[2:])

        if self.previousMotionSeek and (attribs[0][0] != "F"):
            # go to the last G0
            self.currentPath.append([self.g0target[0], self.g0target[1], self.g0target[2]])
            self.previousMotionSeek = False

        for attr in attribs:
            if attr[0] == 'F':
                self.adjustFeedRate(float(attr[1]))
                return
            if attr[0] == 'X':
                target[0] = float(attr[1])
            elif attr[0] == 'Y':
                target[1] = float(attr[1])
            elif attr[0] == 'Z':
                target[2] = float(attr[1])
        self.currentPath.append([target[0], target[1], target[2]])

    def adjustFeedRate(self, newFeedRate):
        if self.feedRate != newFeedRate:
            self.feedRate = newFeedRate
        else:
            if self.debug:
                print("#adjustFeedRate ignoring duplicate speed")

    def adjustTraverseRate(self, newTraverseRate):
        if self.traverseRate == newTraverseRate:
            if self.debug:
                print("#adjustTraverseRate ignoring duplicate speed")
        else:
            self.traverseRate = newTraverseRate
                
    def startNewPass(self):
        if len(self.currentPath) > 0:
            print("#TODO close current path")

        # find/create a corresponding passes entry with a matching color
        # (so we can share DBA files with lasersaur frontend)
        passLen = len(self.passes)
        
        if passLen > 0:
            for p in self.passes:
                if self.intensity == p["intensity"] and self.feedRate == p["feedrate"]:
                    print("#found matching speed/intensity rate index %d" % p["items"])
                else:
                    i = []
                    i.append(len(self.passes))
                    self.passes.append({"items":i, "intensity":self.intensity, "feedrate":self.feedRate, "pxsize":0.4})
        else:
            self.passes.append({"items":[0], "intensity":self.intensity, "feedrate":self.feedRate, "pxsize":0.4})


    def parseS(self, line):
        attribs = self.re_findall_attribs(line)
        for attr in attribs:
            if attr[0] == 'S':
                intensity = float(attr[1])
                if intensity == self.currentIntensity:
                    return
                else:
                    self.intensity = intensity
                    self.startNewPass()
            else:
                print("#WARNING: unknown attribute ", attr[0])
    
    def wontParse(self, line):
        return

