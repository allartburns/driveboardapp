__author__ = 'jet <jet@allartburns.org>'

import math
import sys
import re
import os.path
import StringIO

import dba

class NGCParser:
    """Parse subset of G-code that we can implement on the Lasersaur.

    Challenge: the lasersaur backend converts input files (DXF, SVG)
    to an interpreted format, the frontend UI takes direction from
    the end user, then g-code is generated.

    For this parser, we blindly accept whatever g-code is sent as if
    has come from the frontend.  We'll send back a DBA file an

    G-code generated by the lasersaur, *'d items are one that
    can import to DBA format.
    * G0 X1 Y1 traverse the head to 1,1 (done)
    * G0 F100 sets the traverse speed to 100mm/min (done)
    * G1 X1 Y1 cut the head to 1,1 (done)
    * G1 F100 sets the cut speed to 100mm/min (done)
    G4 pierce (TBD)
    G10 set offsets
    G10 L20 P0 - set table offset (G54) to current location
    G10 L20 P1 - set custom offset (G55) to current location
    G10 L2 P0 X20 Y20 - set table offset (G54) to 20,20
    G10 L2 P1 X220 Y140 - set custom offset (G55) to 220,140
    G30 homing cycle
    G54 use table switch offset
    G55 use custom swich offset
    G90 absolute coordinates
    G91 relative cooridantes
    * M80 air assist enable
    * M81 air assist disable
    M82 aux1 enable
    M83 aux1 disable
    M84 aux2 enable
    M85 aux2 disable

    * S spindle speed == intensity (done)
    
    Fake G-code:
    ! immediately stop operation, pause mode
    ~ contine, exit pause mode
    ? get full status string

TODO: 
- implement air control
- test with a bunch of different ngc files
- handle g-code comments

    """

    def __init__(self, tolerance):

        self.debug = False
        self.version = 0001

        ## parsing varibles
        self.colors = ['#FF0000',
                       '#FFFF00',
                       '#00FF00',
                       '#00FFFF',
                       '#0000FF',
                       '#CC33CC',
                       '#000000']

        self.re_findall_attribs = re.compile('(S|F|X|Y|Z)(-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)').findall

        self.previousMotionSeek = False
        self.g0target = [0.0, 0.0, 0.0]

        self.path = []
        self.intensity = 0
        self.traverseRate = 0
        self.feedRate = 0


        # interpret g-code as absolute positions
        self.absolute = True

        # array of paths by item
        self.passes = {}
        self.currentIndex = -1

        # stats for this job
        self.stats = {}


        
    def parse(self, ngcstring):
        lines = ngcstring.split('\n')
        for line in lines:
            line = line.replace(' ', '')
            if len(line) == 0:
                continue
            if line.startswith('G0'):
                self.parseG0(line)
            elif line.startswith('G1'):
                self.parseG1(line)
            elif line.startswith('S'):
                self.parseS(line)
            elif line.startswith('G90'):
                self.parseG90()
            #dba does not have a control for turning power on or off
            elif line.startswith('M80') or line.startswith('M81'):
                if self.debug:
                    print("ignoring %s" % line)
            else:
                self.cantParse(line)

        #clean up the final parsed items if there was not
        #a layer change at the end of the ngc
        self.updatePaths();

        if 0:
            # check to see if there was a final seek motion and update
            # the final pass
            if self.previousMotionSeek:
                # go to the last G0
                self.path.append([self.g0target[0], self.g0target[1], self.g0target[2]])
                self.previousMotionSeek = False
                self.updatePaths();
                self.currentIndex += 1
            
        job = {'head':{}, 'passes':[], 'items':[], 'defs':[], 'stats':[]}

        job['head']["optimized"] = 0.08
        job['head']["allow_optimize"] = False

        for i in range(0, self.currentIndex):
            defStr = {"kind":"path","data":self.passes[i].Defs()}
            job["defs"].append(defStr)
            job["passes"].append(self.passes[i].PassDetails())
            job["items"].append(self.passes[i].Item())
        return job


    def parseG0(self, line):
        if len(self.path) > 0:
            self.updatePaths()

        # we parse all the G0 commands but only care about the last
        # one before a cut or the last before the end of the ngc file
        attribs = self.re_findall_attribs(line[2:])
        for attr in attribs:
            if attr[0] == 'X':
                self.g0target[0] = float(attr[1])
                self.previousMotionSeek = True
            elif attr[0] == 'Y':
                self.g0target[1] = float(attr[1])
                self.previousMotionSeek = True
            elif attr[0] == 'Z':
                self.g0target[2] = float(attr[1])
                self.previousMotionSeek = True
            elif attr[0] == 'F':
                self.adjustTraverseRate(float(attr[1]))


    def parseG1(self, line):
        target = [0.0, 0.0, 0.0]
        attribs = self.re_findall_attribs(line[2:])

        if self.previousMotionSeek:
            # go to the last G0
            self.path.append([self.g0target[0], self.g0target[1], self.g0target[2]])
            self.previousMotionSeek = False

        for attr in attribs:
            if attr[0] == 'X':
                target[0] = float(attr[1])
            elif attr[0] == 'Y':
                target[1] = float(attr[1])
            elif attr[0] == 'Z':
                target[2] = float(attr[1])
            elif attr[0] == 'F':
                self.adjustFeedRate(float(attr[1]))
        if target != [0.0, 0.0, 0.0]:
            self.path.append([target[0], target[1], target[2]])

    def parseG90(self):
        self.absolute = True

    def adjustFeedRate(self, newFeedRate):
        if self.feedRate != newFeedRate:
            self.feedRate = newFeedRate
        else:
            if self.debug:
                print("#adjustFeedRate ignoring duplicate speed %d " % newFeedRate)

    def adjustTraverseRate(self, newTraverseRate):
        if self.traverseRate == newTraverseRate:
            if self.debug:
                print("#adjustTraverseRate ignoring duplicate speed  %d " % newTraverseRate)
        else:
            self.traverseRate = newTraverseRate

                
    def startNewPass(self):
        if self.currentIndex >= 0:
            self.updatePaths()

        self.currentIndex += 1
        if self.debug:
            print("#startnewpass")
            print ("#starting new pass intensity %d index %d" % (self.intensity, self.currentIndex))
 
        dbapass = dba.DBAPass()
        i = []
        i.append(self.currentIndex)
        dbapass.SetPassDetails(i, self.traverseRate, self.feedRate, self.intensity)
        dbapass.SetItem(self.currentIndex, self.colors[self.currentIndex % len(self.colors)])
        self.passes[self.currentIndex] = dbapass


    def updatePaths(self):
        if len(self.path) > 0:
            self.passes[self.currentIndex].AddDef(self.path)
            self.path = []


    def parseS(self, line):
        attribs = self.re_findall_attribs(line)
        for attr in attribs:
            if attr[0] == 'S':
                intensity = int((float(attr[1]) / float(255)) * 100)
                if self.debug:
                    print("intensity parsed %d" % intensity)
                if intensity == self.intensity:
                    return
                else:
                    self.intensity = intensity
                    self.startNewPass()
            else:
                print("#WARNING: unknown attribute ", attr[0])
    
    def cantParse(self, line):
        print("#can't parse >%s<" % line)

