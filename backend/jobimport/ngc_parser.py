__author__ = 'jet <jet@allartburns.org>'

import math
import sys
import re
import os.path
import StringIO

class NGCParser:
    """Parse subset of G-code that we can implement on the Lasersaur.

    Challenge: the lasersaur backend converts input files (DXF, SVG)
    to an interpreted format, the frontend UI takes direction from
    the end user, then g-code is generated.

    For this parser, we blindly accept whatever g-code is sent as if
    has come from the frontend.  We'll send back a DBA file an

    G-code generated by the lasersaur, *'d items are one that
    can import to DBA format.
    * G0 X1 Y1 traverse the head to 1,1 (done)
    * G0 F100 sets the traverse speed to 100mm/min (done)
    * G1 X1 Y1 cut the head to 1,1 (done)
    * G1 F100 sets the cut speed to 100mm/min (done)
    G4 pierce (TBD)
    G10 set offsets
    G10 L20 P0 - set table offset (G54) to current location
    G10 L20 P1 - set custom offset (G55) to current location
    G10 L2 P0 X20 Y20 - set table offset (G54) to 20,20
    G10 L2 P1 X220 Y140 - set custom offset (G55) to 220,140
    G30 homing cycle
    G54 use table switch offset
    G55 use custom swich offset
    G90 absolute coordinates
    G91 relative cooridantes
    * M80 air assist enable
    * M81 air assist disable
    M82 aux1 enable
    M83 aux1 disable
    M84 aux2 enable
    M85 aux2 disable

    * S spindle speed == intensity (done)
    
    Fake G-code:
    ! immediately stop operation, pause mode
    ~ contine, exit pause mode
    ? get full status string

TODO: 
- implement air control
- test with a bunch of different ngc files
- handle g-code comments

    """

    def __init__(self, tolerance):

        self.debug = False
        self.version = 0001
  
        self.colors = ['#FF0000',
                       '#FFFF00',
                       '#00FF00',
                       '#00FFFF',
                       '#0000FF',
                       '#CC33CC',
                       '#000000']

        self.re_findall_attribs = re.compile('(S|F|X|Y|Z)(-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)').findall
        self.previousMotionSeek = False

        self.currentPath = []
        self.intensity = 0
        self.traverseRate = 0
        self.feedRate = 0

        self.g0target = [0.0, 0.0, 0.0]

        # array of paths by item
#        self.pathsByIndex = {0:[]}
        self.pathsByIndex = {}
        self.currentIndex = -1

        # list of pass characteristics, format is
        # { path index, feedrate, intensity }
#        self.passesByIndex = {0:{}}
        self.passesByIndex = {}

        # stats for this job
        #  bounding box, len
        #  { [x1,y1,x2,y2], 100 }
        self.stats = []


        
    def parse(self, ngcstring):
        lines = ngcstring.split('\n')
        for line in lines:
            line = line.replace(' ', '')
            if line.startswith('G0'):
                self.parseG0(line)
            elif line.startswith('G1'):
                self.parseG1(line)
            elif line.startswith('S'):
                self.parseS(line)
            else:
                self.wontParse(line)

        #clean up the final parsed items if there was not
        #a layer change at the end of the ngc
        self.updatePathsByIndex();

        if 0:
            # check to see if there was a final seek motion and update
            # the final pass
            if self.previousMotionSeek:
                # go to the last G0
                self.currentPath.append([self.g0target[0], self.g0target[1], self.g0target[2]])
                self.previousMotionSeek = False
                self.updatePathsByIndex();
                self.currentIndex += 1
            
        job = {'head':{}, 'passes':[], 'items':[], 'defs':[]}

        job['head']["optimized"] = 0.08
        job['head']["allow_optimize"] = False

        for i in range(0, self.currentIndex):
            defStr = {"kind":"path","data":self.pathsByIndex[i]}
            job["defs"].append(defStr)
            job["passes"].append(self.passesByIndex[i])
            job["items"].append({"color": self.colors[i % len(self.colors)], 'def': i})
        return job


    def parseG0(self, line):
        if len(self.currentPath) > 0:
            self.updatePathsByIndex()

        # we parse all the G0 commands but only care about the last
        # one before a cut or the last before the end of the ngc file
        attribs = self.re_findall_attribs(line[2:])
        for attr in attribs:
            if attr[0] == 'X':
                self.g0target[0] = float(attr[1])
                self.previousMotionSeek = True
            elif attr[0] == 'Y':
                self.g0target[1] = float(attr[1])
                self.previousMotionSeek = True
            elif attr[0] == 'Z':
                self.g0target[2] = float(attr[1])
                self.previousMotionSeek = True
            elif attr[0] == 'F':
                self.adjustTraverseRate(float(attr[1]))


    def parseG1(self, line):
        target = [0.0, 0.0, 0.0]
        attribs = self.re_findall_attribs(line[2:])

        if self.previousMotionSeek:
            # go to the last G0
            self.currentPath.append([self.g0target[0], self.g0target[1], self.g0target[2]])
            self.previousMotionSeek = False

        for attr in attribs:
            if attr[0] == 'X':
                target[0] = float(attr[1])
            elif attr[0] == 'Y':
                target[1] = float(attr[1])
            elif attr[0] == 'Z':
                target[2] = float(attr[1])
            elif attr[0] == 'F':
                self.adjustFeedRate(float(attr[1]))
        if target != [0.0, 0.0, 0.0]:
            self.currentPath.append([target[0], target[1], target[2]])


    def adjustFeedRate(self, newFeedRate):
        if self.feedRate != newFeedRate:
            self.feedRate = newFeedRate
        else:
            if self.debug:
                print("#adjustFeedRate ignoring duplicate speed %d " % newFeedRate)

    def adjustTraverseRate(self, newTraverseRate):
        if self.traverseRate == newTraverseRate:
            if self.debug:
                print("#adjustTraverseRate ignoring duplicate speed  %d " % newTraverseRate)
        else:
            self.traverseRate = newTraverseRate

                
    def startNewPass(self):

        if self.currentIndex >= 0:
            self.updatePathsByIndex()

        self.currentIndex += 1
        if self.debug:
            print("#startnewpass")
            print ("#starting new pass intensity %d index %d" % (self.intensity, self.currentIndex))
 
        i = []
        i.append(self.currentIndex)
        self.passesByIndex[self.currentIndex] = {"items":i, "intensity":self.intensity, "seekrate":self.traverseRate, "feedrate":self.feedRate, "pxsize":0.4}
        self.pathsByIndex[self.currentIndex] = []


    def updatePathsByIndex(self):
        if len(self.currentPath) > 0:
            if self.currentIndex not in self.pathsByIndex:
                self.pathsByIndex[self.currentIndex] = self.currentPath
            else:
                self.pathsByIndex[self.currentIndex].append(self.currentPath)
            self.currentPath = []


    def parseS(self, line):
        attribs = self.re_findall_attribs(line)
        for attr in attribs:
            if attr[0] == 'S':
                intensity = int((float(attr[1]) / float(255)) * 100)
                if self.debug:
                    print("intensity parsed %d" % intensity)
                if intensity == self.intensity:
                    return
                else:
                    self.intensity = intensity
                    self.startNewPass()
            else:
                print("#WARNING: unknown attribute ", attr[0])
    
    def wontParse(self, line):
        return

