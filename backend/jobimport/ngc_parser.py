__author__ = 'jet <jet@allartburns.org>'

import math
import sys
import re
import os.path
import StringIO


class NGCParser:
    """Parse subset of G-code that we can implement on the Lasersaur.

    Challenge: the lasersaur software converts input files (DXF, SVG)
    to an interpreted format, then uses external controls in the UI
    to generate G-code.  Do we toss out the G-code generated by external
    controls and treat this like an input file??

    G-code generated by the lasersaur:
    G0 X1 Y1 traverse the head to 1,1
    G0 F100 sets the traverse speed to 100mm/min
    G1 X1 Y1 cut the head to 1,1
    G1 F100 sets the cut speed to 100mm/min
    G4 pierce (TBD)
    G10 set offsets
    G10 L20 P0 - set table offset (G54) to current location
    G10 L20 P1 - set custom offset (G55) to current location
    G10 L2 P0 X20 Y20 - set table offset (G54) to 20,20
    G10 L2 P1 X220 Y140 - set custom offset (G55) to 220,140
    G30 homing cycle
    G54 use table switch offset
    G55 use custom swich offset
    G90 absolute coordinates
    G91 relative cooridantes
    M80 air assist enable
    M81 air assist disable
    M82 aux1 enable
    M83 aux1 disable
    M84 aux2 enable
    M85 aux2 disable

    S spindle speed == intensity
    
    Fake G-code:
    ! immediately stop operation, pause mode
    ~ contine, exit pause mode
    ? get full status string


    """



    def __init__(self):

        self.debug = True

  
        self.re_findall_attribs = re.compile('(S|F|X|Y|Z)(-?[0-9]+\.?[0-9]*(?:e-?[0-9]*)?)').findall
        self.previousMotionSeek = True
        # each entry:
        # speed:[list of paths]
        # and we build the job.defs by going through these in order
        self.paths = {}
        self.currentPath = []
        self.g0target = []


        
    def parse(self, ngcstring):

        self.intensity = 0.0
        self.feedRate = 0.0
        self.g0target = [0.0, 0.0, 0.0]


        lines = ngcstring.split('\n')
        for line in lines:
            line = line.replace(' ', '')
            if line.startswith('G0'):
                self.parseG0(line)
            elif line.startswith('G1'):
                self.parseG1(line)
            elif line.startswith('S'):
                self.parseS(line)
            else:
                self.wontParse(line)

        job = {'head':{}, 'passes':[], 'items':[], 'defs':[]}

        for path in self.pathsByRate:
            job['defs'].append({"kind":"path",
                                "speed":path,
                                "data":self.pathsByRate[path]})

        return job


    def parseG0(self, line):
        # we parse all the G0 commands but only care about the last
        # one before a cut
        print("parse G0 " + line);
        attribs = self.re_findall_attribs(line[2:])
        for attr in attribs:
            if attr[0] == 'X':
                self.g0target[0] = float(attr[1])
            elif attr[0] == 'Y':
                self.g0target[1] = float(attr[1])
            elif attr[0] == 'Z':
                self.g0target[2] = float(attr[1])
            # elif attr[0] == 'F':
                # do nothing, we use the host traverse rate
        self.previousMotionSeek = True


    def parseG1(self, line):
        print("parse G1 " + line);
        if self.previousMotionSeek:
            # go to the last G0
            self.paths.append([[self.g0target[0], self.g0target[1], self.g0target[2]]])
            self.currentPath = self.paths[-1]
            self.previousMotionSeek = False

        target = [0.0, 0.0, 0.0]
        attribs = self.re_findall_attribs(line[2:])
        for attr in attribs:
            if attr[0] == 'X':
                target[0] = float(attr[1])
            elif attr[0] == 'Y':
                target[1] = float(attr[1])
            elif attr[0] == 'Z':
                target[2] = float(attr[1])
            elif attr[0] == 'S':
                intensity = float(attr[1])
            elif attr[0] == 'F':
                self.adjustFeedRate(float(attr[1]))
        self.appendPath([target[0], target[1], target[2]])


    def adjustFeedRate(self, newFeedRate):

        if self.feedRate == newFeedRate:
            if self.debug:
                print("adjustFeedRate ignoring duplicate speed")
            return
 
"""
append speed and currentPath to paths
set currentPath to empty string
set currentRate

"""



                  
    def appendPath(self, path):
        if self.color == 1:
            self.red_colorLayer.append(path)
        elif self.color == 2:
            self.yellow_colorLayer.append(path)
        elif self.color == 3:
            self.green_colorLayer.append(path)
        elif self.color == 4:
            self.cyan_colorLayer.append(path)
        elif self.color == 5:
            self.blue_colorLayer.append(path)
        elif self.color == 6:
            self.magenta_colorLayer.append(path) 
        elif self.color == 7:
            self.black_colorLayer.append(path)
    
    def parseS(self, line):
        attribs = self.re_findall_attribs(line)
        for attr in attribs:
            if attr[0] == 'S':
                intensity = float(attr[1])

    
    def wontParse(self, line):
        return

